<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OS: ipc_recv.c File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/d67/ipc__recv_8c.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ipc_recv.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../d4/d73/ipc__private_8h_source.html">ipc/ipc_private.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/ddb/pmalloc_8h_source.html">pmalloc/pmalloc.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adfdfd780297b2ce87717c12d4e64c184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#adfdfd780297b2ce87717c12d4e64c184">ipc_leave_recv_buffer_pages_mapped</a> (void)</td></tr>
<tr class="memdesc:adfdfd780297b2ce87717c12d4e64c184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave IPC receive buffer pages mapped instead of freeing them.  <a href="#adfdfd780297b2ce87717c12d4e64c184">More...</a><br /></td></tr>
<tr class="separator:adfdfd780297b2ce87717c12d4e64c184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117600d2e5729968ab36daed5889f010"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a117600d2e5729968ab36daed5889f010">ipc_recv_update_behind</a> (bool *freed)</td></tr>
<tr class="memdesc:a117600d2e5729968ab36daed5889f010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the IPC receive buffer behind pointer.  <a href="#a117600d2e5729968ab36daed5889f010">More...</a><br /></td></tr>
<tr class="separator:a117600d2e5729968ab36daed5889f010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c7056eb4cb0bb6a24e6d1485a59d41"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#ab2c7056eb4cb0bb6a24e6d1485a59d41">ipc_signal_interproc_event_handler</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg)</td></tr>
<tr class="separator:ab2c7056eb4cb0bb6a24e6d1485a59d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab15272aa431c6d297792ee6fcc6123"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a8ab15272aa431c6d297792ee6fcc6123">ipc_recv_should_sleep</a> (void)</td></tr>
<tr class="memdesc:a8ab15272aa431c6d297792ee6fcc6123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <a class="el" href="../../d6/d67/ipc__recv_8c.html#aa1a5046ffae5016d0fa3984cd07ae4e6" title="Blocking receive: shallow sleeps until either a message is seen with the supplied ID...">ipc_recv()</a> should try to sleep.  <a href="#a8ab15272aa431c6d297792ee6fcc6123">More...</a><br /></td></tr>
<tr class="separator:a8ab15272aa431c6d297792ee6fcc6123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db3259307147a494d551bb167bf962e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a0db3259307147a494d551bb167bf962e">ipc_recv_try_to_sleep</a> (<a class="el" href="../../d5/dd3/rtime__types_8h.html#afc21bac5ad596b618b484908da356c0c">TIME</a> timeout)</td></tr>
<tr class="memdesc:a0db3259307147a494d551bb167bf962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the processor into shallow sleep if possible.  <a href="#a0db3259307147a494d551bb167bf962e">More...</a><br /></td></tr>
<tr class="separator:a0db3259307147a494d551bb167bf962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816497aa5c1d3478a90084ce9e8d63d3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a816497aa5c1d3478a90084ce9e8d63d3">ipc_recv_atomic</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> recv_id, void *blocking_msg)</td></tr>
<tr class="memdesc:a816497aa5c1d3478a90084ce9e8d63d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of ipc_recv for when the receiving of the blocking response message should not be pre-empted by high-prioity handlers.  <a href="#a816497aa5c1d3478a90084ce9e8d63d3">More...</a><br /></td></tr>
<tr class="separator:a816497aa5c1d3478a90084ce9e8d63d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a5046ffae5016d0fa3984cd07ae4e6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#aa1a5046ffae5016d0fa3984cd07ae4e6">ipc_recv</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> recv_id, void *blocking_msg)</td></tr>
<tr class="memdesc:aa1a5046ffae5016d0fa3984cd07ae4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking receive: shallow sleeps until either a message is seen with the supplied ID.  <a href="#aa1a5046ffae5016d0fa3984cd07ae4e6">More...</a><br /></td></tr>
<tr class="separator:aa1a5046ffae5016d0fa3984cd07ae4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae612cb6485136546c957c2bf9e7d1569"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#ae612cb6485136546c957c2bf9e7d1569">call_msg_callback</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> id, const void *msg, uint32 msg_length, bool already_stored, void **pblocking_msg, bool *got_blocking)</td></tr>
<tr class="memdesc:ae612cb6485136546c957c2bf9e7d1569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first handler for this message ID in the callback queue, remove it from the queue, then either call the handler if it is not NULL, or, if it is NULL, copy the message into a pmalloc block for subsequent return to the caller (this is the blocking message)  <a href="#ae612cb6485136546c957c2bf9e7d1569">More...</a><br /></td></tr>
<tr class="separator:ae612cb6485136546c957c2bf9e7d1569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8980f1bd95f837003731e418d5139f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#ace8980f1bd95f837003731e418d5139f">ipc_recv_process_postponed_hp_handlers</a> (void)</td></tr>
<tr class="memdesc:ace8980f1bd95f837003731e418d5139f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop through the list of postponed high-priority handlers, calling them one by one.  <a href="#ace8980f1bd95f837003731e418d5139f">More...</a><br /></td></tr>
<tr class="separator:ace8980f1bd95f837003731e418d5139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bb60694fbcca2f59b35a44e5cba907"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#af9bb60694fbcca2f59b35a44e5cba907">ipc_recv_process_out_of_order_rsps</a> (void **blocking_msg)</td></tr>
<tr class="separator:af9bb60694fbcca2f59b35a44e5cba907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d1fffb837acfba25d30d6005b0518"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a091d1fffb837acfba25d30d6005b0518">ipc_recv_handler</a> (void *blocking_msg)</td></tr>
<tr class="memdesc:a091d1fffb837acfba25d30d6005b0518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process everything in the receive buffer.  <a href="#a091d1fffb837acfba25d30d6005b0518">More...</a><br /></td></tr>
<tr class="separator:a091d1fffb837acfba25d30d6005b0518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bd358085dddb1190b342baf3c774a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a759bd358085dddb1190b342baf3c774a">ipc_recv_cb</a> (<a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a> recv_id, <a class="el" href="../../d9/d24/ipc_8h.html#a345a09a9cb6311a36cb4f8c367fb5b1e">IPC_RECV_CB</a> cb)</td></tr>
<tr class="memdesc:a759bd358085dddb1190b342baf3c774a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive to request the framework to pass a single response of the given ID to the given callback.  <a href="#a759bd358085dddb1190b342baf3c774a">More...</a><br /></td></tr>
<tr class="separator:a759bd358085dddb1190b342baf3c774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad922b892c750faa1cd268c436dfc0632"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#ad922b892c750faa1cd268c436dfc0632">ipc_disallow_high_priority_handler_calls</a> (void)</td></tr>
<tr class="memdesc:ad922b892c750faa1cd268c436dfc0632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the IPC currently blocking waiting for a "fast" response message?  <a href="#ad922b892c750faa1cd268c436dfc0632">More...</a><br /></td></tr>
<tr class="separator:ad922b892c750faa1cd268c436dfc0632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ef8b376c1bfbf1329774e8a451434b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a92ef8b376c1bfbf1329774e8a451434b">ipc_high_priority_handler_running</a> (bool start_not_stop)</td></tr>
<tr class="memdesc:a92ef8b376c1bfbf1329774e8a451434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify IPC that a high-priority message handler is about to run/has just finished running synchronously within the IPC handler.  <a href="#a92ef8b376c1bfbf1329774e8a451434b">More...</a><br /></td></tr>
<tr class="separator:a92ef8b376c1bfbf1329774e8a451434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a897916cceacab9559325e5064b2971b6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d67/ipc__recv_8c.html#a897916cceacab9559325e5064b2971b6">leave_pages_mapped</a> = FALSE</td></tr>
<tr class="memdesc:a897916cceacab9559325e5064b2971b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the IPC receive buffer pages mapped in if set to TRUE.  <a href="#a897916cceacab9559325e5064b2971b6">More...</a><br /></td></tr>
<tr class="separator:a897916cceacab9559325e5064b2971b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae612cb6485136546c957c2bf9e7d1569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae612cb6485136546c957c2bf9e7d1569">&#9670;&nbsp;</a></span>call_msg_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool call_msg_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>msg_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>already_stored</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pblocking_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>got_blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first handler for this message ID in the callback queue, remove it from the queue, then either call the handler if it is not NULL, or, if it is NULL, copy the message into a pmalloc block for subsequent return to the caller (this is the blocking message) </p>
<dl class="section note"><dt>Note</dt><dd>It is worth removing the handler from the queue before execution as the callback may modify the queue (e.g. to repost itself as a handler).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Message ID we're searching for </td></tr>
    <tr><td class="paramname">msg</td><td>Message body to pass to callback </td></tr>
    <tr><td class="paramname">msg_length</td><td>Byte length of message body </td></tr>
    <tr><td class="paramname">already_stored</td><td>Flag to indicate that the message being processed is already stored on the out of order queue, so it shouldn't be stored again </td></tr>
    <tr><td class="paramname">pblocking_msg</td><td>Pointer to the pointer to space for the blocking msg to be returned to the caller in. </td></tr>
    <tr><td class="paramname">got_blocking</td><td>Flag to be returned to indicate whether <code>pblocking_msg</code> has been filled in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a callback was found (and called) else FALSE (indicating a logical error) </dd></dl>

</div>
</div>
<a id="ad922b892c750faa1cd268c436dfc0632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad922b892c750faa1cd268c436dfc0632">&#9670;&nbsp;</a></span>ipc_disallow_high_priority_handler_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ipc_disallow_high_priority_handler_calls </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the IPC currently blocking waiting for a "fast" response message? </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if so, else FALSE </dd></dl>

</div>
</div>
<a id="a92ef8b376c1bfbf1329774e8a451434b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ef8b376c1bfbf1329774e8a451434b">&#9670;&nbsp;</a></span>ipc_high_priority_handler_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_high_priority_handler_running </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>start_not_stop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify IPC that a high-priority message handler is about to run/has just finished running synchronously within the IPC handler. </p>
<p>This must be used to bracket handler functions that call "fast" traps. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_not_stop</td><td>TRUE indicates the handler is about to start, FALSE that it is about to stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdfd780297b2ce87717c12d4e64c184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdfd780297b2ce87717c12d4e64c184">&#9670;&nbsp;</a></span>ipc_leave_recv_buffer_pages_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_leave_recv_buffer_pages_mapped </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave IPC receive buffer pages mapped instead of freeing them. </p>
<p>Once a page has finished being used the IPC receive buffer can either free the page or leave it to be reused later on. Freeing the page saves on RAM at the expense of making it more difficult to debug the IPC module.</p>
<p>If the IpcLeaveRecvBufferPagesMapped MIB key is set this function should be called to leave the IPC receive buffer pages mapped in, otherwise they will be freed. </p>

</div>
</div>
<a id="aa1a5046ffae5016d0fa3984cd07ae4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a5046ffae5016d0fa3984cd07ae4e6">&#9670;&nbsp;</a></span>ipc_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ipc_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blocking_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking receive: shallow sleeps until either a message is seen with the supplied ID. </p>
<p>Returns a copy of the received payload in a local pmalloc'd block. Ownership is assumed by the caller.</p>
<p>Note: the receive handler underlying this call will process everything else it finds in the receive buffer and then return control to this function. Hence non-blocking message handlers should avoid making blocking IPC calls themselves, to avoid inadvertently blocking out any current blocking call for a long time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_id</td><td>IPC message to receive </td></tr>
    <tr><td class="paramname">blocking_msg</td><td>Pointer to pre-allocated space for the expected message, or NULL if the message should be pmalloc'd internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the message body: simply equal to <code>blocking_msg</code> if this is not NULL, else points to an internally pmalloc'd copy of the message </dd></dl>

</div>
</div>
<a id="a816497aa5c1d3478a90084ce9e8d63d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816497aa5c1d3478a90084ce9e8d63d3">&#9670;&nbsp;</a></span>ipc_recv_atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ipc_recv_atomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>msg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blocking_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of ipc_recv for when the receiving of the blocking response message should not be pre-empted by high-prioity handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg_id</td><td>IPC message to receive </td></tr>
    <tr><td class="paramname">blocking_msg</td><td>Pointer to pre-allocated space for the expected message, or NULL if the message should be pmalloc'd internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the message body: simply equal to <code>blocking_msg</code> if this is not NULL, else points to an internally pmalloc'd copy of the message </dd></dl>

</div>
</div>
<a id="a759bd358085dddb1190b342baf3c774a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bd358085dddb1190b342baf3c774a">&#9670;&nbsp;</a></span>ipc_recv_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ipc_recv_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>recv_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d24/ipc_8h.html#a345a09a9cb6311a36cb4f8c367fb5b1e">IPC_RECV_CB</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking receive to request the framework to pass a single response of the given ID to the given callback. </p>
<p>To simulate a permanent handler, the callback should call this function again during execution to re-post itself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recv_id</td><td>The message ID that will trigger the callback </td></tr>
    <tr><td class="paramname">cb</td><td>The callback itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091d1fffb837acfba25d30d6005b0518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091d1fffb837acfba25d30d6005b0518">&#9670;&nbsp;</a></span>ipc_recv_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ipc_recv_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blocking_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process everything in the receive buffer. </p>
<p>If the current blocking_msg_id is encountered amongst them, save a copy of the payload in a local pmalloc block and return it to the caller after everything has been processed. Ownership of the memory is passed to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking_msg</td><td>Pointer to pre-allocated space for any expected message, or NULL if the message should be pmalloc'd internally. If this function isn't being called in the context of blocking, the value is irrelevant, except that it will be returned unchanged, so it is highly recommended to pass NULL, so that the case where an blocking message is erroneously received can be detected (e.g. see <code><a class="el" href="../../df/df4/ipc__sched_8c.html#a8c70f0b5e8a53fdbb7c6a47ee59aeeb6">ipc_background_handler()</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the blocking message body, if any: equal to <code>blocking_msg</code> if this is not NULL, else points to an internally pmalloc'd copy of the message if there was one, else NULL </dd></dl>

</div>
</div>
<a id="af9bb60694fbcca2f59b35a44e5cba907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bb60694fbcca2f59b35a44e5cba907">&#9670;&nbsp;</a></span>ipc_recv_process_out_of_order_rsps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ipc_recv_process_out_of_order_rsps </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blocking_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace8980f1bd95f837003731e418d5139f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8980f1bd95f837003731e418d5139f">&#9670;&nbsp;</a></span>ipc_recv_process_postponed_hp_handlers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc_recv_process_postponed_hp_handlers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loop through the list of postponed high-priority handlers, calling them one by one. </p>
<p>Note: the list may be modified as we go as a result of calls to atomic blocking traps by the high-priority handlers. That is logically safe as we read the next pointer only after this can have happened. For it to lead to us staying in the loop for a long time, it would be necessary for further trigger messages to keep arriving at a very high rate, i.e. fast enough to keep arriving during blocking calls the handlers are making. But this indicates a more fundamental problem in terms of P1 processing data fast enough, so we can assume here that this'll be OK. </p>

</div>
</div>
<a id="a8ab15272aa431c6d297792ee6fcc6123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab15272aa431c6d297792ee6fcc6123">&#9670;&nbsp;</a></span>ipc_recv_should_sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ipc_recv_should_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether <a class="el" href="../../d6/d67/ipc__recv_8c.html#aa1a5046ffae5016d0fa3984cd07ae4e6" title="Blocking receive: shallow sleeps until either a message is seen with the supplied ID...">ipc_recv()</a> should try to sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE If there's no pending work and it's safe to sleep. </dd>
<dd>
FALSE If <a class="el" href="../../d6/d67/ipc__recv_8c.html#aa1a5046ffae5016d0fa3984cd07ae4e6" title="Blocking receive: shallow sleeps until either a message is seen with the supplied ID...">ipc_recv()</a> shouldn't sleep. </dd></dl>

</div>
</div>
<a id="a0db3259307147a494d551bb167bf962e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db3259307147a494d551bb167bf962e">&#9670;&nbsp;</a></span>ipc_recv_try_to_sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc_recv_try_to_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/dd3/rtime__types_8h.html#afc21bac5ad596b618b484908da356c0c">TIME</a>&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the processor into shallow sleep if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout to pass to the sleep function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a117600d2e5729968ab36daed5889f010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117600d2e5729968ab36daed5889f010">&#9670;&nbsp;</a></span>ipc_recv_update_behind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc_recv_update_behind </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>freed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the IPC receive buffer behind pointer. </p>
<p>Either frees the now unused buffer pages or leaves them mapped in depending on the value of <code>leave_pages_mapped</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">freed</td><td>Points to a bool to track whether the behind has already been updated or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2c7056eb4cb0bb6a24e6d1485a59d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c7056eb4cb0bb6a24e6d1485a59d41">&#9670;&nbsp;</a></span>ipc_signal_interproc_event_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ipc_signal_interproc_event_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d88/ipc__prim_8h.html#a06fa3898c777e365dda72551f0720b93">IPC_SIGNAL_ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a897916cceacab9559325e5064b2971b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897916cceacab9559325e5064b2971b6">&#9670;&nbsp;</a></span>leave_pages_mapped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool leave_pages_mapped = FALSE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaves the IPC receive buffer pages mapped in if set to TRUE. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_9104b11b055a08855e18ab07d1360a34.html">apps_ext_adk64r_RC_CI_qcc512x_qcc302x_1908091004</a></li><li class="navelem"><a class="el" href="../../dir_19c4644e84b768df42bf93899dbb4e83.html">apps_package</a></li><li class="navelem"><a class="el" href="../../dir_e9f51238b5eab91050ba7b42263dc658.html">progfiles</a></li><li class="navelem"><a class="el" href="../../dir_86fefe393b7ca9a63838560cf4ca04cf.html">apps</a></li><li class="navelem"><a class="el" href="../../dir_240681f6dc407f95ae9103d80499b5b4.html">fw</a></li><li class="navelem"><a class="el" href="../../dir_67a3fc20251395f7d62aa73621d4d7c9.html">src</a></li><li class="navelem"><a class="el" href="../../dir_721b2a6acf65b21a05ec9c4de6b97c06.html">core</a></li><li class="navelem"><a class="el" href="../../dir_7ea9e1f68719b86e36e3df60a7d8f0f6.html">ipc</a></li><li class="navelem"><a class="el" href="../../d6/d67/ipc__recv_8c.html">ipc_recv.c</a></li>
    <li class="footer">Copyright (c) 2019 Qualcomm Technologies International, Ltd. Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
