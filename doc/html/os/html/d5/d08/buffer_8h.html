<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OS: buffer.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d08/buffer_8h.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">buffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Application Subsystem buffer subsystem main public header file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="../../d5/dd9/hydra__types_8h_source.html">hydra/hydra_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d2/df1/mmu_8h_source.html">mmu/mmu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dd/df8/io__defs_8h_source.html">io/io_defs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/d4b/hal_8h_source.html">hal/hal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../dd/db4/buffer__msg_8h_source.html">buffer/buffer_msg.h</a>&quot;</code><br />
</div>
<p><a href="../../d5/d08/buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer structure itself.  <a href="../../d3/d1a/structBUFFER.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2ea4d9f659736e20d5fc3c31571a0b5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a2ea4d9f659736e20d5fc3c31571a0b5e">IO_DEFS_MODULE_APPS_SYS_CPU0_VM</a>&#160;&#160;&#160;/* for mmu_buffer_size */</td></tr>
<tr class="separator:a2ea4d9f659736e20d5fc3c31571a0b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cbc3e711b5b8194b92df4764079b10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a95cbc3e711b5b8194b92df4764079b10">buf_save_state</a>(save_state)&#160;&#160;&#160;((void)(save_state))</td></tr>
<tr class="memdesc:a95cbc3e711b5b8194b92df4764079b10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../d5/d08/buffer_8h.html#a95cbc3e711b5b8194b92df4764079b10" title="buf_save_state() simply calls the corresponding MMU routine. ">buf_save_state()</a></code> simply calls the corresponding MMU routine.  <a href="#a95cbc3e711b5b8194b92df4764079b10">More...</a><br /></td></tr>
<tr class="separator:a95cbc3e711b5b8194b92df4764079b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24f3e35d90753a325e997d509d5fd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#aed24f3e35d90753a325e997d509d5fd8">buf_restore_state</a>(restore_state)&#160;&#160;&#160;((void)(restore_state))</td></tr>
<tr class="memdesc:aed24f3e35d90753a325e997d509d5fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="../../d5/d08/buffer_8h.html#aed24f3e35d90753a325e997d509d5fd8" title="buf_restore_state() simply calls the corresponding MMU routine. ">buf_restore_state()</a></code> simply calls the corresponding MMU routine.  <a href="#aed24f3e35d90753a325e997d509d5fd8">More...</a><br /></td></tr>
<tr class="separator:aed24f3e35d90753a325e997d509d5fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cdd63a3bf728fe502777e83112e90f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#af1cdd63a3bf728fe502777e83112e90f">buf_clone_update_index</a>(clone,  src)&#160;&#160;&#160;((clone)-&gt;index = (src)-&gt;index)</td></tr>
<tr class="memdesc:af1cdd63a3bf728fe502777e83112e90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro implementation.  <a href="#af1cdd63a3bf728fe502777e83112e90f">More...</a><br /></td></tr>
<tr class="separator:af1cdd63a3bf728fe502777e83112e90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfa4a1db442df64910b3f7da9210863"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#adcfa4a1db442df64910b3f7da9210863">buf_read_port_close</a>()&#160;&#160;&#160;<a class="el" href="../../d2/d49/mmu__proc__port_8h.html#a19787f6590d24ba8befae40c96c0525e">mmu_read_port_close</a>()</td></tr>
<tr class="memdesc:adcfa4a1db442df64910b3f7da9210863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make mmu read port close visible at the buffer level.  <a href="#adcfa4a1db442df64910b3f7da9210863">More...</a><br /></td></tr>
<tr class="separator:adcfa4a1db442df64910b3f7da9210863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9211ac8cb95458212697edb0825967e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ac9211ac8cb95458212697edb0825967e">buf_write_port_close</a>()&#160;&#160;&#160;<a class="el" href="../../d2/d49/mmu__proc__port_8h.html#aed7a776bbe11844b09861f370a531be6">mmu_write_port_close</a>()</td></tr>
<tr class="memdesc:ac9211ac8cb95458212697edb0825967e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make mmu write port close visible at the buffer level.  <a href="#ac9211ac8cb95458212697edb0825967e">More...</a><br /></td></tr>
<tr class="separator:ac9211ac8cb95458212697edb0825967e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Macros for pointer arithmetic and information retrieval.</div></td></tr>
<tr class="memitem:a6b56e35e4c551546d0ae2cdd96bf9fa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>(hi,  lo,  mask)&#160;&#160;&#160;((uint16)(((hi) - (lo)) &amp; (mask)))</td></tr>
<tr class="memdesc:a6b56e35e4c551546d0ae2cdd96bf9fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract buffer indices with mask to take account of wrap.  <a href="#a6b56e35e4c551546d0ae2cdd96bf9fa3">More...</a><br /></td></tr>
<tr class="separator:a6b56e35e4c551546d0ae2cdd96bf9fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e09f5c30cac4a3fe82923d26773b05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>(buf)&#160;&#160;&#160;((uint16)((buf)-&gt;size_mask + 1U))</td></tr>
<tr class="memdesc:a04e09f5c30cac4a3fe82923d26773b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast operation to fetch the size of the buffer in octets.  <a href="#a04e09f5c30cac4a3fe82923d26773b05">More...</a><br /></td></tr>
<tr class="separator:a04e09f5c30cac4a3fe82923d26773b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe484ed60268d0d4dc80432c7b783ec5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#abe484ed60268d0d4dc80432c7b783ec5">BUF_SUB_INDICES</a>(buf,  hi,  lo)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>(hi, lo, (buf)-&gt;size_mask)</td></tr>
<tr class="memdesc:abe484ed60268d0d4dc80432c7b783ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract buffer indices given the buffer.  <a href="#abe484ed60268d0d4dc80432c7b783ec5">More...</a><br /></td></tr>
<tr class="separator:abe484ed60268d0d4dc80432c7b783ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a233176b999243cbb142f5db1e342"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a786a233176b999243cbb142f5db1e342">BUF_ADD_INDICES</a>(buf,  a,  b)&#160;&#160;&#160;((uint16)(((a) + (b)) &amp; (buf)-&gt;size_mask))</td></tr>
<tr class="separator:a786a233176b999243cbb142f5db1e342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7668162adcf7868565671ff32d016c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#abc7668162adcf7868565671ff32d016c">BUF_UPDATE_POINTER</a>(buf,  pointer,  octets)&#160;&#160;&#160;((void)(pointer = (uint16)(((pointer) + (octets)) &amp; ((buf)-&gt;size_mask))))</td></tr>
<tr class="memdesc:abc7668162adcf7868565671ff32d016c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a buffer pointer by a certain amount.  <a href="#abc7668162adcf7868565671ff32d016c">More...</a><br /></td></tr>
<tr class="separator:abc7668162adcf7868565671ff32d016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db336066964eab08eaff499254440c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a9db336066964eab08eaff499254440c5">BUF_SYNC_INDEX_TO_WR_HANDLE</a>(buf)</td></tr>
<tr class="separator:a9db336066964eab08eaff499254440c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0280fe27616ad27dff1e5c9eae72357d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a0280fe27616ad27dff1e5c9eae72357d">BUF_SYNC_OUTDEX_TO_RD_HANDLE</a>(buf)</td></tr>
<tr class="separator:a0280fe27616ad27dff1e5c9eae72357d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af631935de442568cee91cba03f1f26fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#af631935de442568cee91cba03f1f26fc">BUF_GET_AVAILABLE</a>(buf)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;index, (buf)-&gt;outdex, (buf)-&gt;size_mask)</td></tr>
<tr class="memdesc:af631935de442568cee91cba03f1f26fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets available to be read from a buffer.  <a href="#af631935de442568cee91cba03f1f26fc">More...</a><br /></td></tr>
<tr class="separator:af631935de442568cee91cba03f1f26fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97ab31b0607a57a0897e13e8d27d6eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ab97ab31b0607a57a0897e13e8d27d6eb">BUF_GET_USED</a>(buf)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;index, (buf)-&gt;tail, (buf)-&gt;size_mask)</td></tr>
<tr class="memdesc:ab97ab31b0607a57a0897e13e8d27d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets in use in a buffer.  <a href="#ab97ab31b0607a57a0897e13e8d27d6eb">More...</a><br /></td></tr>
<tr class="separator:ab97ab31b0607a57a0897e13e8d27d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09cae78f986f550205e309d76369dfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ab09cae78f986f550205e309d76369dfd">BUF_GET_UNFREED</a>(buf)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;outdex, (buf)-&gt;tail, (buf)-&gt;size_mask)</td></tr>
<tr class="memdesc:ab09cae78f986f550205e309d76369dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets that have been passed for further processing but not freed.  <a href="#ab09cae78f986f550205e309d76369dfd">More...</a><br /></td></tr>
<tr class="separator:ab09cae78f986f550205e309d76369dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7b8eb1ab82ca006794abe5decbe6b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7e7b8eb1ab82ca006794abe5decbe6b0">BUF_GET_FREESPACE</a>(buf)</td></tr>
<tr class="memdesc:a7e7b8eb1ab82ca006794abe5decbe6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets of free space available in a buffer.  <a href="#a7e7b8eb1ab82ca006794abe5decbe6b0">More...</a><br /></td></tr>
<tr class="separator:a7e7b8eb1ab82ca006794abe5decbe6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c737d085588534749761303c3b2bf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#af9c737d085588534749761303c3b2bf6">BUF_GET_USABLESPACE</a>(buf_size)</td></tr>
<tr class="separator:af9c737d085588534749761303c3b2bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049e18ae52bdaa245370aae3f0c58ff8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a049e18ae52bdaa245370aae3f0c58ff8">BUF_GET_FREESPACE_STATIC</a>(buf)</td></tr>
<tr class="memdesc:a049e18ae52bdaa245370aae3f0c58ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets of free space available for statically managed buffer.  <a href="#a049e18ae52bdaa245370aae3f0c58ff8">More...</a><br /></td></tr>
<tr class="separator:a049e18ae52bdaa245370aae3f0c58ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fad5d590b843dd9a6e0c5f6c2bc2a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ab0fad5d590b843dd9a6e0c5f6c2bc2a8">BUF_GET_FREESPACE_STATIC_FROM_INDEX</a>(buf,  index)</td></tr>
<tr class="memdesc:ab0fad5d590b843dd9a6e0c5f6c2bc2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return octets of free space available for a statically managed buffer using an index value outside the normal buffer structure.  <a href="#ab0fad5d590b843dd9a6e0c5f6c2bc2a8">More...</a><br /></td></tr>
<tr class="separator:ab0fad5d590b843dd9a6e0c5f6c2bc2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7749277b248801efb02ce0aee772280d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7749277b248801efb02ce0aee772280d">BUFFER</a></td></tr>
<tr class="memdesc:a7749277b248801efb02ce0aee772280d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer structure itself.  <a href="#a7749277b248801efb02ce0aee772280d">More...</a><br /></td></tr>
<tr class="separator:a7749277b248801efb02ce0aee772280d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4194054835aa28e3944513bcd10000e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#aa4194054835aa28e3944513bcd10000e">buf_save_state</a> (<a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="separator:aa4194054835aa28e3944513bcd10000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc64024808b973f06e93754aea39b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a12fc64024808b973f06e93754aea39b9">buf_restore_state</a> (const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="separator:a12fc64024808b973f06e93754aea39b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b273934759560ffc281566415d38f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ab4b273934759560ffc281566415d38f1">buf_clone_update_index</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *clone_buf, const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *source_buf)</td></tr>
<tr class="memdesc:ab4b273934759560ffc281566415d38f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the index of a clone buffer to match that of the buffer it was cloned from.  <a href="#ab4b273934759560ffc281566415d38f1">More...</a><br /></td></tr>
<tr class="separator:ab4b273934759560ffc281566415d38f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a891a6ecf96d24606d170e96af5681cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a891a6ecf96d24606d170e96af5681cfd">buf_init_from_handle</a> (mmu_buffer_size msize, <a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a> h, <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a891a6ecf96d24606d170e96af5681cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure around an already-created MMU handle.  <a href="#a891a6ecf96d24606d170e96af5681cfd">More...</a><br /></td></tr>
<tr class="separator:a891a6ecf96d24606d170e96af5681cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4428b4d1ece0651892adbd72c3ec18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#acc4428b4d1ece0651892adbd72c3ec18">buf_new_from_handle</a> (mmu_buffer_size msize, <a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a> h)</td></tr>
<tr class="memdesc:acc4428b4d1ece0651892adbd72c3ec18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and set up a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure around an already-created MMU handle.  <a href="#acc4428b4d1ece0651892adbd72c3ec18">More...</a><br /></td></tr>
<tr class="separator:acc4428b4d1ece0651892adbd72c3ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7feef3c1d2edf4148f4d6df364e83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a1d7feef3c1d2edf4148f4d6df364e83e">buf_free_from_handle</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a1d7feef3c1d2edf4148f4d6df364e83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure allocated by <code>buf_new_buffer_handle</code>.  <a href="#a1d7feef3c1d2edf4148f4d6df364e83e">More...</a><br /></td></tr>
<tr class="separator:a1d7feef3c1d2edf4148f4d6df364e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Use of buffer pointers "raw" (without application framing).</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpebbf835bb312b74a77557cbffff2a4cc"></a>The code below updates buffer pointers based on lengths passed directly.</p>
<p>For the <code><a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a></code> interface this is the only available method. </p>
</td></tr>
<tr class="memitem:a6fdb2427659f55768fbe4809aff06d5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit</a>(buf)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#add61b72438ea4a46db80e4b91298589d">buf_raw_write_map_8bit_position</a>(buf, (buf)-&gt;index)</td></tr>
<tr class="separator:a6fdb2427659f55768fbe4809aff06d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bbf3b5fc9f2ee5dfbe7235ad9a065c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c">buf_raw_write_update</a>(buf,  octets)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#abc7668162adcf7868565671ff32d016c">BUF_UPDATE_POINTER</a>(buf, (buf)-&gt;index, octets)</td></tr>
<tr class="memdesc:a43bbf3b5fc9f2ee5dfbe7235ad9a065c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updating the index can be done as a macro.  <a href="#a43bbf3b5fc9f2ee5dfbe7235ad9a065c">More...</a><br /></td></tr>
<tr class="separator:a43bbf3b5fc9f2ee5dfbe7235ad9a065c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb3ffe11ef8e820d91906282016fd93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93">buf_raw_read_update</a>(buf,  octets)&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#abc7668162adcf7868565671ff32d016c">BUF_UPDATE_POINTER</a>(buf, (buf)-&gt;outdex, octets)</td></tr>
<tr class="memdesc:afbb3ffe11ef8e820d91906282016fd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updating the outdex can be done as a macro.  <a href="#afbb3ffe11ef8e820d91906282016fd93">More...</a><br /></td></tr>
<tr class="separator:afbb3ffe11ef8e820d91906282016fd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c057c785d19297e6ba74f2f48f488d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a2c057c785d19297e6ba74f2f48f488d4">buf_raw_update_tail_no_free</a>(buf,  new_tail)&#160;&#160;&#160;do{ (buf)-&gt;tail = (uint16)((new_tail) &amp; (<a class="el" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>((buf)) - 1)); }while(0)</td></tr>
<tr class="memdesc:a2c057c785d19297e6ba74f2f48f488d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the tail pointer.  <a href="#a2c057c785d19297e6ba74f2f48f488d4">More...</a><br /></td></tr>
<tr class="separator:a2c057c785d19297e6ba74f2f48f488d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06e9de8299f864e44d69fb078cffe3b"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ac06e9de8299f864e44d69fb078cffe3b">buf_raw_write_map_8bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:ac06e9de8299f864e44d69fb078cffe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an 8-bit pointer to write data to a buffer.  <a href="#ac06e9de8299f864e44d69fb078cffe3b">More...</a><br /></td></tr>
<tr class="separator:ac06e9de8299f864e44d69fb078cffe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add61b72438ea4a46db80e4b91298589d"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#add61b72438ea4a46db80e4b91298589d">buf_raw_write_map_8bit_position</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 offset)</td></tr>
<tr class="memdesc:add61b72438ea4a46db80e4b91298589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalisation of <code>buf_raw_write_map_8bit</code> to return read/write access at an arbitrary position within the buffer.  <a href="#add61b72438ea4a46db80e4b91298589d">More...</a><br /></td></tr>
<tr class="separator:add61b72438ea4a46db80e4b91298589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72afd9466f19bd0c8bbff2a796624f66"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66">buf_raw_write_map_16bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a72afd9466f19bd0c8bbff2a796624f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 16-bit pointer to write data to a buffer.  <a href="#a72afd9466f19bd0c8bbff2a796624f66">More...</a><br /></td></tr>
<tr class="separator:a72afd9466f19bd0c8bbff2a796624f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87e8d2c8f79a06fcb8bca6c608f2add"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ac87e8d2c8f79a06fcb8bca6c608f2add">buf_raw_write_map_16bit_be</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:ac87e8d2c8f79a06fcb8bca6c608f2add"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code> but map words big-endian.  <a href="#ac87e8d2c8f79a06fcb8bca6c608f2add">More...</a><br /></td></tr>
<tr class="separator:ac87e8d2c8f79a06fcb8bca6c608f2add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d7283d658069aff4371deb75af60df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a32d7283d658069aff4371deb75af60df">buf_raw_write_only_unmap</a> (void)</td></tr>
<tr class="memdesc:a32d7283d658069aff4371deb75af60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">buf_raw_write_only_unmap - unmap the buffer for writing ONLY.  <a href="#a32d7283d658069aff4371deb75af60df">More...</a><br /></td></tr>
<tr class="separator:a32d7283d658069aff4371deb75af60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355996f344f863eeb53b20c964ed1207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a355996f344f863eeb53b20c964ed1207">buf_raw_write_unmap</a> (void)</td></tr>
<tr class="memdesc:a355996f344f863eeb53b20c964ed1207"><td class="mdescLeft">&#160;</td><td class="mdescRight">buf_raw_write_unmap - unmap the buffer from reading and writing.  <a href="#a355996f344f863eeb53b20c964ed1207">More...</a><br /></td></tr>
<tr class="separator:a355996f344f863eeb53b20c964ed1207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad399d8df2a54cbf038824af7f44ee61e"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ad399d8df2a54cbf038824af7f44ee61e">buf_raw_write_only_map_8bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:ad399d8df2a54cbf038824af7f44ee61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit()</a></code>, but map write only, not read/write.  <a href="#ad399d8df2a54cbf038824af7f44ee61e">More...</a><br /></td></tr>
<tr class="separator:ad399d8df2a54cbf038824af7f44ee61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac188166a34563d506f78a4e8edf44b3a"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ac188166a34563d506f78a4e8edf44b3a">buf_raw_write_only_map_8bit_save_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:ac188166a34563d506f78a4e8edf44b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#ad399d8df2a54cbf038824af7f44ee61e" title="As buf_raw_write_map_8bit(), but map write only, not read/write. ">buf_raw_write_only_map_8bit()</a></code>, but save the buffer state.  <a href="#ac188166a34563d506f78a4e8edf44b3a">More...</a><br /></td></tr>
<tr class="separator:ac188166a34563d506f78a4e8edf44b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecb3dff3a3de6075aed7727dbb8984"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ad0ecb3dff3a3de6075aed7727dbb8984">buf_raw_write_only_map_16bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:ad0ecb3dff3a3de6075aed7727dbb8984"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code>, but map write only, not read/write.  <a href="#ad0ecb3dff3a3de6075aed7727dbb8984">More...</a><br /></td></tr>
<tr class="separator:ad0ecb3dff3a3de6075aed7727dbb8984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66caf410e5a9e077886195afb45c277a"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a66caf410e5a9e077886195afb45c277a">buf_raw_write_only_map_16bit_be</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a66caf410e5a9e077886195afb45c277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#ad0ecb3dff3a3de6075aed7727dbb8984" title="As buf_raw_write_map_16bit(), but map write only, not read/write. ">buf_raw_write_only_map_16bit()</a></code>, but map words big-endian.  <a href="#a66caf410e5a9e077886195afb45c277a">More...</a><br /></td></tr>
<tr class="separator:a66caf410e5a9e077886195afb45c277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7246abc8b54d560da27322f13c9b2f64"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7246abc8b54d560da27322f13c9b2f64">buf_raw_write_map_8bit_save_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:a7246abc8b54d560da27322f13c9b2f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit()</a></code>, but save the buffer state.  <a href="#a7246abc8b54d560da27322f13c9b2f64">More...</a><br /></td></tr>
<tr class="separator:a7246abc8b54d560da27322f13c9b2f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c1fd4e30b5ed58969c5bbb21afcef0"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a53c1fd4e30b5ed58969c5bbb21afcef0">buf_raw_write_map_16bit_save_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:a53c1fd4e30b5ed58969c5bbb21afcef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code>, but save the buffer state.  <a href="#a53c1fd4e30b5ed58969c5bbb21afcef0">More...</a><br /></td></tr>
<tr class="separator:a53c1fd4e30b5ed58969c5bbb21afcef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2417ba06058092bb6a576f528dbb98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a1b2417ba06058092bb6a576f528dbb98">buf_raw_write_update</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 octets)</td></tr>
<tr class="memdesc:a1b2417ba06058092bb6a576f528dbb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <code>index</code> for a buffer after writing <code>octets</code> octets to it.  <a href="#a1b2417ba06058092bb6a576f528dbb98">More...</a><br /></td></tr>
<tr class="separator:a1b2417ba06058092bb6a576f528dbb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c58d0e9eeb322481a98e1c44655d62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a5c58d0e9eeb322481a98e1c44655d62b">buf_raw_write_update_restore_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 octets, const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:a5c58d0e9eeb322481a98e1c44655d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update()</a></code> but restore a previously saved buffer state.  <a href="#a5c58d0e9eeb322481a98e1c44655d62b">More...</a><br /></td></tr>
<tr class="separator:a5c58d0e9eeb322481a98e1c44655d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fca5a3daf2be592424b0c2451cc74e0"><td class="memItemLeft" align="right" valign="top">const uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a3fca5a3daf2be592424b0c2451cc74e0">buf_raw_read_map_8bit</a> (const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a3fca5a3daf2be592424b0c2451cc74e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an 8-bit pointer to read data from a buffer.  <a href="#a3fca5a3daf2be592424b0c2451cc74e0">More...</a><br /></td></tr>
<tr class="separator:a3fca5a3daf2be592424b0c2451cc74e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6dfd642c59dc5c805d058c752aeab4"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a4b6dfd642c59dc5c805d058c752aeab4">buf_raw_read_write_map_8bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a4b6dfd642c59dc5c805d058c752aeab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an 8-bit pointer to read and write data in a buffer.  <a href="#a4b6dfd642c59dc5c805d058c752aeab4">More...</a><br /></td></tr>
<tr class="separator:a4b6dfd642c59dc5c805d058c752aeab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384130a90d9f0150b9a0e55d6eddc0b1"><td class="memItemLeft" align="right" valign="top">const uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1">buf_raw_read_map_16bit</a> (const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a384130a90d9f0150b9a0e55d6eddc0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 16-bit pointer to read data from a buffer.  <a href="#a384130a90d9f0150b9a0e55d6eddc0b1">More...</a><br /></td></tr>
<tr class="separator:a384130a90d9f0150b9a0e55d6eddc0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c619412abae7035e1d19ca400354445"><td class="memItemLeft" align="right" valign="top">const uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a6c619412abae7035e1d19ca400354445">buf_raw_read_map_16bit_be</a> (const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a6c619412abae7035e1d19ca400354445"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1" title="Return a 16-bit pointer to read data from a buffer. ">buf_raw_read_map_16bit()</a></code>, but map words big-endian.  <a href="#a6c619412abae7035e1d19ca400354445">More...</a><br /></td></tr>
<tr class="separator:a6c619412abae7035e1d19ca400354445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7852702c4b87f8fcc72e80e2a5f99085"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7852702c4b87f8fcc72e80e2a5f99085">buf_raw_read_write_map_16bit</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a7852702c4b87f8fcc72e80e2a5f99085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an 16-bit pointer to read and write data in a buffer.  <a href="#a7852702c4b87f8fcc72e80e2a5f99085">More...</a><br /></td></tr>
<tr class="separator:a7852702c4b87f8fcc72e80e2a5f99085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfcaa61798e84d3a3195feb45941d20"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a6bfcaa61798e84d3a3195feb45941d20">buf_raw_read_write_map_16bit_be</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf)</td></tr>
<tr class="memdesc:a6bfcaa61798e84d3a3195feb45941d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a7852702c4b87f8fcc72e80e2a5f99085" title="Return an 16-bit pointer to read and write data in a buffer. ">buf_raw_read_write_map_16bit()</a></code> but map words big-endian.  <a href="#a6bfcaa61798e84d3a3195feb45941d20">More...</a><br /></td></tr>
<tr class="separator:a6bfcaa61798e84d3a3195feb45941d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693faf6ae446d42d36c95103edb9923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7693faf6ae446d42d36c95103edb9923">buf_raw_read_unmap</a> (void)</td></tr>
<tr class="memdesc:a7693faf6ae446d42d36c95103edb9923"><td class="mdescLeft">&#160;</td><td class="mdescRight">buf_raw_read_only_unmap - unmap the buffer from reading ONLY.  <a href="#a7693faf6ae446d42d36c95103edb9923">More...</a><br /></td></tr>
<tr class="separator:a7693faf6ae446d42d36c95103edb9923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d85451a93ba4de7f15cdab10b84fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a26d85451a93ba4de7f15cdab10b84fa9">buf_raw_read_write_unmap</a> (void)</td></tr>
<tr class="memdesc:a26d85451a93ba4de7f15cdab10b84fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">buf_raw_read_write_unmap - unmap the buffer from reading and writing.  <a href="#a26d85451a93ba4de7f15cdab10b84fa9">More...</a><br /></td></tr>
<tr class="separator:a26d85451a93ba4de7f15cdab10b84fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995bef6dac1e7993c4b2bc24fc39a798"><td class="memItemLeft" align="right" valign="top">const uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a995bef6dac1e7993c4b2bc24fc39a798">buf_raw_read_map_8bit_save_state</a> (const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:a995bef6dac1e7993c4b2bc24fc39a798"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a3fca5a3daf2be592424b0c2451cc74e0" title="Return an 8-bit pointer to read data from a buffer. ">buf_raw_read_map_8bit()</a></code>, but save the buffer state.  <a href="#a995bef6dac1e7993c4b2bc24fc39a798">More...</a><br /></td></tr>
<tr class="separator:a995bef6dac1e7993c4b2bc24fc39a798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2747238ccd5d9e5826bfef2b1437835"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#af2747238ccd5d9e5826bfef2b1437835">buf_raw_read_write_map_8bit_save_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:af2747238ccd5d9e5826bfef2b1437835"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a995bef6dac1e7993c4b2bc24fc39a798" title="As buf_raw_read_map_8bit(), but save the buffer state. ">buf_raw_read_map_8bit_save_state()</a></code>, but mapped read/write.  <a href="#af2747238ccd5d9e5826bfef2b1437835">More...</a><br /></td></tr>
<tr class="separator:af2747238ccd5d9e5826bfef2b1437835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1487fe4d868796279b6617b561efbd4"><td class="memItemLeft" align="right" valign="top">const uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#af1487fe4d868796279b6617b561efbd4">buf_raw_read_map_16bit_save_state</a> (const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:af1487fe4d868796279b6617b561efbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1" title="Return a 16-bit pointer to read data from a buffer. ">buf_raw_read_map_16bit()</a></code>, but save the buffer state.  <a href="#af1487fe4d868796279b6617b561efbd4">More...</a><br /></td></tr>
<tr class="separator:af1487fe4d868796279b6617b561efbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72d4f6deec19d1aac30c95ea7007022"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#ae72d4f6deec19d1aac30c95ea7007022">buf_raw_read_write_map_16bit_save_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:ae72d4f6deec19d1aac30c95ea7007022"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#af1487fe4d868796279b6617b561efbd4" title="As buf_raw_read_map_16bit(), but save the buffer state. ">buf_raw_read_map_16bit_save_state()</a></code>, but mapped read/write.  <a href="#ae72d4f6deec19d1aac30c95ea7007022">More...</a><br /></td></tr>
<tr class="separator:ae72d4f6deec19d1aac30c95ea7007022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2034090b59dc9cb8991cbb3073a137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a7d2034090b59dc9cb8991cbb3073a137">buf_raw_read_update</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 octets)</td></tr>
<tr class="memdesc:a7d2034090b59dc9cb8991cbb3073a137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update <code>outdex</code> for a buffer after reading <code>octets</code> octets from it.  <a href="#a7d2034090b59dc9cb8991cbb3073a137">More...</a><br /></td></tr>
<tr class="separator:a7d2034090b59dc9cb8991cbb3073a137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ac40d544d4d88d1c77174adf41d4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#aab3ac40d544d4d88d1c77174adf41d4c">buf_raw_read_update_restore_state</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 octets, const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *save_state)</td></tr>
<tr class="memdesc:aab3ac40d544d4d88d1c77174adf41d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <code><a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update()</a></code> but restore a previously saved buffer state.  <a href="#aab3ac40d544d4d88d1c77174adf41d4c">More...</a><br /></td></tr>
<tr class="separator:aab3ac40d544d4d88d1c77174adf41d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4067623274d4ad0a35209e8e5633ccc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/buffer_8h.html#a4067623274d4ad0a35209e8e5633ccc2">buf_raw_update_tail_free</a> (<a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *buf, uint16 new_tail)</td></tr>
<tr class="memdesc:a4067623274d4ad0a35209e8e5633ccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the tail pointer, freeing any memory no longer needed.  <a href="#a4067623274d4ad0a35209e8e5633ccc2">More...</a><br /></td></tr>
<tr class="separator:a4067623274d4ad0a35209e8e5633ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Application Subsystem buffer subsystem main public header file. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a786a233176b999243cbb142f5db1e342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786a233176b999243cbb142f5db1e342">&#9670;&nbsp;</a></span>BUF_ADD_INDICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_ADD_INDICES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((uint16)(((a) + (b)) &amp; (buf)-&gt;size_mask))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1cdd63a3bf728fe502777e83112e90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cdd63a3bf728fe502777e83112e90f">&#9670;&nbsp;</a></span>buf_clone_update_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_clone_update_index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">clone, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((clone)-&gt;index = (src)-&gt;index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro implementation. </p>

</div>
</div>
<a id="af631935de442568cee91cba03f1f26fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af631935de442568cee91cba03f1f26fc">&#9670;&nbsp;</a></span>BUF_GET_AVAILABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_AVAILABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;index, (buf)-&gt;outdex, (buf)-&gt;size_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return octets available to be read from a buffer. </p>
<p>This is the difference between the input pointer (<code>index</code>) and the output pointer (<code>outdex</code>) assuming wrapping pointers. This value will usually be read by the thread that is managing output from the buffer and hence the <code>outdex</code> pointer. Note that the <code>index</code> may be advanced asynchronously by the input thread. </p>

</div>
</div>
<a id="a7e7b8eb1ab82ca006794abe5decbe6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7b8eb1ab82ca006794abe5decbe6b0">&#9670;&nbsp;</a></span>BUF_GET_FREESPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_FREESPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>(buf) -                                         \</div><div class="line">     BUF_SUB_INDICES_MASK((buf)-&gt;index,                                 \</div><div class="line">                          (<a class="code" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>(buf) == <a class="code" href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a>)? \</div><div class="line">                          (buf)-&gt;tail :                                 \</div><div class="line">                          (buf)-&gt;tail &amp; ~(uint16)(<a class="code" href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a>-1),    \</div><div class="line">                          (buf)-&gt;size_mask)) - 1U)</div><div class="ttc" id="buffer_8h_html_a04e09f5c30cac4a3fe82923d26773b05"><div class="ttname"><a href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a></div><div class="ttdeci">#define BUF_GET_SIZE_OCTETS(buf)</div><div class="ttdoc">Fast operation to fetch the size of the buffer in octets. </div><div class="ttdef"><b>Definition:</b> buffer.h:138</div></div>
<div class="ttc" id="memmap_8h_html_adfea4ca4f9dd59bd4054c26d03315b7b"><div class="ttname"><a href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a></div><div class="ttdeci">#define MMU_PAGE_BYTES</div><div class="ttdoc">MMU buffer page size (in bytes) </div><div class="ttdef"><b>Definition:</b> memmap.h:68</div></div>
</div><!-- fragment -->
<p>Return octets of free space available in a buffer. </p>
<p>This is (buffer size - the difference between the input pointer (<code>index</code>) and the output pointer (<code>tail</code>) assuming wrapping pointers). This value will usually be read by the thread that is writing data to the buffer to know whether it has enough space to write the data.</p>
<p>This has 1 subtracted in order that the buffer never becomes full, which would cause the indices to become confused (there is no distinction between the values that differ by a multiple of the buffer size).</p>
<p>For buffers with more than a single page we need to ensure that the index does not advance onto the same page as the tail, since then if we free data at the tail we will free the page with the new data. Hence mask tail back to the start of the page (keeping the "-1" to simplify the calculation). Buffers with a single page will never have that page freed during use so the calculation is simplified in that case. </p>

</div>
</div>
<a id="a049e18ae52bdaa245370aae3f0c58ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049e18ae52bdaa245370aae3f0c58ff8">&#9670;&nbsp;</a></span>BUF_GET_FREESPACE_STATIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_FREESPACE_STATIC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>(buf) -                                         \</div><div class="line">     (<a class="code" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;index, (buf)-&gt;tail, (buf)-&gt;size_mask) + 1U))</div><div class="ttc" id="buffer_8h_html_a04e09f5c30cac4a3fe82923d26773b05"><div class="ttname"><a href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a></div><div class="ttdeci">#define BUF_GET_SIZE_OCTETS(buf)</div><div class="ttdoc">Fast operation to fetch the size of the buffer in octets. </div><div class="ttdef"><b>Definition:</b> buffer.h:138</div></div>
<div class="ttc" id="buffer_8h_html_a6b56e35e4c551546d0ae2cdd96bf9fa3"><div class="ttname"><a href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a></div><div class="ttdeci">#define BUF_SUB_INDICES_MASK(hi, lo, mask)</div><div class="ttdoc">Subtract buffer indices with mask to take account of wrap. </div><div class="ttdef"><b>Definition:</b> buffer.h:130</div></div>
</div><!-- fragment -->
<p>Return octets of free space available for statically managed buffer. </p>
<p>This differs from <code><a class="el" href="../../d5/d08/buffer_8h.html#a7e7b8eb1ab82ca006794abe5decbe6b0" title="Return octets of free space available in a buffer. ">BUF_GET_FREESPACE()</a></code> in that it should only be used in <code><a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a></code> structures where memory is never freed dynamically (only on buffer destruction). In that case we do not need to take account of whether <code>index</code> and <code>tail</code> are on the same page. </p>

</div>
</div>
<a id="ab0fad5d590b843dd9a6e0c5f6c2bc2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fad5d590b843dd9a6e0c5f6c2bc2a8">&#9670;&nbsp;</a></span>BUF_GET_FREESPACE_STATIC_FROM_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_FREESPACE_STATIC_FROM_INDEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>(buf) -                                         \</div><div class="line">     BUF_SUB_INDICES_MASK((index), (buf)-&gt;tail, (buf)-&gt;size_mask) - 1U)</div><div class="ttc" id="buffer_8h_html_a04e09f5c30cac4a3fe82923d26773b05"><div class="ttname"><a href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a></div><div class="ttdeci">#define BUF_GET_SIZE_OCTETS(buf)</div><div class="ttdoc">Fast operation to fetch the size of the buffer in octets. </div><div class="ttdef"><b>Definition:</b> buffer.h:138</div></div>
</div><!-- fragment -->
<p>Return octets of free space available for a statically managed buffer using an index value outside the normal buffer structure. </p>
<p>As with <code><a class="el" href="../../d5/d08/buffer_8h.html#a049e18ae52bdaa245370aae3f0c58ff8" title="Return octets of free space available for statically managed buffer. ">BUF_GET_FREESPACE_STATIC()</a></code> it should only be used in <code><a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a></code> structures where memory is never freed dynamically (only on buffer destruction). In that case we do not need to take account of whether <code>index</code> and <code>tail</code> are on the same page. </p>

</div>
</div>
<a id="a04e09f5c30cac4a3fe82923d26773b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e09f5c30cac4a3fe82923d26773b05">&#9670;&nbsp;</a></span>BUF_GET_SIZE_OCTETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_SIZE_OCTETS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;((uint16)((buf)-&gt;size_mask + 1U))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast operation to fetch the size of the buffer in octets. </p>
<p>The buffer is assumed to be no larger than 32k octets. This is a pretty good bet. </p>

</div>
</div>
<a id="ab09cae78f986f550205e309d76369dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09cae78f986f550205e309d76369dfd">&#9670;&nbsp;</a></span>BUF_GET_UNFREED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_UNFREED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;outdex, (buf)-&gt;tail, (buf)-&gt;size_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return octets that have been passed for further processing but not freed. </p>
<p>This is the difference between the <code>outdex</code> and <code>tail</code> pointers, so indicates if any data has been processed by advancing <code>outdex</code> but not freed by advancing tail. Otherwise it is similar to <code><a class="el" href="../../d5/d08/buffer_8h.html#af631935de442568cee91cba03f1f26fc" title="Return octets available to be read from a buffer. ">BUF_GET_AVAILABLE()</a></code>. </p>

</div>
</div>
<a id="af9c737d085588534749761303c3b2bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c737d085588534749761303c3b2bf6">&#9670;&nbsp;</a></span>BUF_GET_USABLESPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_USABLESPACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf_size</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(uint16)((((buf_size) == <a class="code" href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a>)?    \</div><div class="line">        (buf_size) :                                \</div><div class="line">        (buf_size) - <a class="code" href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a>) - 1U)</div><div class="ttc" id="memmap_8h_html_adfea4ca4f9dd59bd4054c26d03315b7b"><div class="ttname"><a href="../../de/dc8/memmap_8h.html#adfea4ca4f9dd59bd4054c26d03315b7b">MMU_PAGE_BYTES</a></div><div class="ttdeci">#define MMU_PAGE_BYTES</div><div class="ttdoc">MMU buffer page size (in bytes) </div><div class="ttdef"><b>Definition:</b> memmap.h:68</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab97ab31b0607a57a0897e13e8d27d6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97ab31b0607a57a0897e13e8d27d6eb">&#9670;&nbsp;</a></span>BUF_GET_USED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_USED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>((buf)-&gt;index, (buf)-&gt;tail, (buf)-&gt;size_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return octets in use in a buffer. </p>
<p>This is the difference between the <code>index</code> and <code>tail</code> pointers, so indicates if any data has been written the buffer without being cleared. Otherwise it is similar to <code><a class="el" href="../../d5/d08/buffer_8h.html#af631935de442568cee91cba03f1f26fc" title="Return octets available to be read from a buffer. ">BUF_GET_AVAILABLE()</a></code>. </p>

</div>
</div>
<a id="afbb3ffe11ef8e820d91906282016fd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb3ffe11ef8e820d91906282016fd93">&#9670;&nbsp;</a></span>buf_raw_read_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_raw_read_update</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">octets&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#abc7668162adcf7868565671ff32d016c">BUF_UPDATE_POINTER</a>(buf, (buf)-&gt;outdex, octets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updating the outdex can be done as a macro. </p>

</div>
</div>
<a id="a2c057c785d19297e6ba74f2f48f488d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c057c785d19297e6ba74f2f48f488d4">&#9670;&nbsp;</a></span>buf_raw_update_tail_no_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_raw_update_tail_no_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">new_tail&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do{ (buf)-&gt;tail = (uint16)((new_tail) &amp; (<a class="el" href="../../d5/d08/buffer_8h.html#a04e09f5c30cac4a3fe82923d26773b05">BUF_GET_SIZE_OCTETS</a>((buf)) - 1)); }while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the tail pointer. </p>
<p>The new pointer is used to replace the old tail pointer. Any memory between the two pointers may be reused but isn't freed.</p>
<p>This function does not map buffer memory.</p>
<p>Note the difference in parameters between this and functions that update after writing (<code>index</code>) or reading (<code>outdex</code>): in this case, the second parameter is the new value of the <code>tail</code>, not the length to add to the old <code>tail</code>. I'm not sure why that is. </p>

</div>
</div>
<a id="a6fdb2427659f55768fbe4809aff06d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdb2427659f55768fbe4809aff06d5e">&#9670;&nbsp;</a></span>buf_raw_write_map_8bit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_raw_write_map_8bit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#add61b72438ea4a46db80e4b91298589d">buf_raw_write_map_8bit_position</a>(buf, (buf)-&gt;index)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43bbf3b5fc9f2ee5dfbe7235ad9a065c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bbf3b5fc9f2ee5dfbe7235ad9a065c">&#9670;&nbsp;</a></span>buf_raw_write_update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_raw_write_update</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">octets&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#abc7668162adcf7868565671ff32d016c">BUF_UPDATE_POINTER</a>(buf, (buf)-&gt;index, octets)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updating the index can be done as a macro. </p>

</div>
</div>
<a id="adcfa4a1db442df64910b3f7da9210863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfa4a1db442df64910b3f7da9210863">&#9670;&nbsp;</a></span>buf_read_port_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_read_port_close</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d2/d49/mmu__proc__port_8h.html#a19787f6590d24ba8befae40c96c0525e">mmu_read_port_close</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make mmu read port close visible at the buffer level. </p>

</div>
</div>
<a id="aed24f3e35d90753a325e997d509d5fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed24f3e35d90753a325e997d509d5fd8">&#9670;&nbsp;</a></span>buf_restore_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_restore_state</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">restore_state</td><td>)</td>
          <td>&#160;&#160;&#160;((void)(restore_state))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="../../d5/d08/buffer_8h.html#aed24f3e35d90753a325e997d509d5fd8" title="buf_restore_state() simply calls the corresponding MMU routine. ">buf_restore_state()</a></code> simply calls the corresponding MMU routine. </p>

</div>
</div>
<a id="a95cbc3e711b5b8194b92df4764079b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cbc3e711b5b8194b92df4764079b10">&#9670;&nbsp;</a></span>buf_save_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_save_state</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save_state</td><td>)</td>
          <td>&#160;&#160;&#160;((void)(save_state))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="../../d5/d08/buffer_8h.html#a95cbc3e711b5b8194b92df4764079b10" title="buf_save_state() simply calls the corresponding MMU routine. ">buf_save_state()</a></code> simply calls the corresponding MMU routine. </p>

</div>
</div>
<a id="abe484ed60268d0d4dc80432c7b783ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe484ed60268d0d4dc80432c7b783ec5">&#9670;&nbsp;</a></span>BUF_SUB_INDICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_SUB_INDICES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lo&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d5/d08/buffer_8h.html#a6b56e35e4c551546d0ae2cdd96bf9fa3">BUF_SUB_INDICES_MASK</a>(hi, lo, (buf)-&gt;size_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract buffer indices given the buffer. </p>

</div>
</div>
<a id="a6b56e35e4c551546d0ae2cdd96bf9fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b56e35e4c551546d0ae2cdd96bf9fa3">&#9670;&nbsp;</a></span>BUF_SUB_INDICES_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_SUB_INDICES_MASK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lo, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((uint16)(((hi) - (lo)) &amp; (mask)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract buffer indices with mask to take account of wrap. </p>
<p>This is used when (as normal) the buffer size is a power of two. </p>

</div>
</div>
<a id="a9db336066964eab08eaff499254440c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db336066964eab08eaff499254440c5">&#9670;&nbsp;</a></span>BUF_SYNC_INDEX_TO_WR_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_SYNC_INDEX_TO_WR_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void) ((buf)-&gt;index = (uint16)(mmu_get_handle_offset((buf)-&gt;handle) &amp; \</div><div class="line">                                                            (buf)-&gt;size_mask)))</div></div><!-- fragment -->
</div>
</div>
<a id="a0280fe27616ad27dff1e5c9eae72357d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0280fe27616ad27dff1e5c9eae72357d">&#9670;&nbsp;</a></span>BUF_SYNC_OUTDEX_TO_RD_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_SYNC_OUTDEX_TO_RD_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void) ((buf)-&gt;outdex = (uint16)(mmu_get_handle_offset((buf)-&gt;handle) &amp; \</div><div class="line">                                                            (buf)-&gt;size_mask)))</div></div><!-- fragment -->
</div>
</div>
<a id="abc7668162adcf7868565671ff32d016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7668162adcf7868565671ff32d016c">&#9670;&nbsp;</a></span>BUF_UPDATE_POINTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_UPDATE_POINTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pointer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">octets&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((void)(pointer = (uint16)(((pointer) + (octets)) &amp; ((buf)-&gt;size_mask))))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a buffer pointer by a certain amount. </p>
<p>Pointer is typically one of index, outdex or tail. It must be an lvalue. </p>

</div>
</div>
<a id="ac9211ac8cb95458212697edb0825967e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9211ac8cb95458212697edb0825967e">&#9670;&nbsp;</a></span>buf_write_port_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_write_port_close</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="../../d2/d49/mmu__proc__port_8h.html#aed7a776bbe11844b09861f370a531be6">mmu_write_port_close</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make mmu write port close visible at the buffer level. </p>

</div>
</div>
<a id="a2ea4d9f659736e20d5fc3c31571a0b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea4d9f659736e20d5fc3c31571a0b5e">&#9670;&nbsp;</a></span>IO_DEFS_MODULE_APPS_SYS_CPU0_VM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IO_DEFS_MODULE_APPS_SYS_CPU0_VM&#160;&#160;&#160;/* for mmu_buffer_size */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7749277b248801efb02ce0aee772280d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7749277b248801efb02ce0aee772280d">&#9670;&nbsp;</a></span>BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a>  <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer structure itself. </p>
<p>This encapsulates an MMU buffer.</p>
<p>A <code><a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a></code> has only one handle, called <code>handle</code>. It is used for both reading from and writing to the buffer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4b273934759560ffc281566415d38f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b273934759560ffc281566415d38f1">&#9670;&nbsp;</a></span>buf_clone_update_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_clone_update_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>clone_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>source_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the index of a clone buffer to match that of the buffer it was cloned from. </p>

</div>
</div>
<a id="a1d7feef3c1d2edf4148f4d6df364e83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7feef3c1d2edf4148f4d6df364e83e">&#9670;&nbsp;</a></span>buf_free_from_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a> buf_free_from_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure allocated by <code>buf_new_buffer_handle</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mmu_handle that was wrapped; this may be useful for issuing a separate request to free the handle </dd></dl>

</div>
</div>
<a id="a891a6ecf96d24606d170e96af5681cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891a6ecf96d24606d170e96af5681cfd">&#9670;&nbsp;</a></span>buf_init_from_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_init_from_handle </td>
          <td>(</td>
          <td class="paramtype">mmu_buffer_size&#160;</td>
          <td class="paramname"><em>msize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure around an already-created MMU handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The MMU handle that has been supplied </td></tr>
    <tr><td class="paramname">msize</td><td>The size associated with the handle </td></tr>
    <tr><td class="paramname">buf</td><td>The <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure to initialise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4428b4d1ece0651892adbd72c3ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4428b4d1ece0651892adbd72c3ec18">&#9670;&nbsp;</a></span>buf_new_from_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a>* buf_new_from_handle </td>
          <td>(</td>
          <td class="paramtype">mmu_buffer_size&#160;</td>
          <td class="paramname"><em>msize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/df1/mmu_8h.html#a171681dffae7d676e767666211e12c2e">mmu_handle</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and set up a <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure around an already-created MMU handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The MMU handle that has been supplied </td></tr>
    <tr><td class="paramname">msize</td><td>The size associated with this handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialised <a class="el" href="../../d3/d1a/structBUFFER.html" title="The buffer structure itself. ">BUFFER</a> structure wrapping the supplied handle </dd></dl>

</div>
</div>
<a id="a384130a90d9f0150b9a0e55d6eddc0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384130a90d9f0150b9a0e55d6eddc0b1">&#9670;&nbsp;</a></span>buf_raw_read_map_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16* buf_raw_read_map_16bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a 16-bit pointer to read data from a buffer. </p>
<p>The buffer is mapped for read access at the output location (<code>outdex</code>) and a pointer is returned. The view of the data is 16-bit-wide. <code>outdex</code> must be even or this causes a panic; the caller must ensure all updates to buffers that will be accessed in 16-bit mode use even byte counts.</p>
<p>After the data is read, <code><a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update()</a></code> should be called to indicate how many octets were read. This updates <code>outdex</code>. Note the argument really is in octets even though half that number of words will have been written. </p>

</div>
</div>
<a id="a6c619412abae7035e1d19ca400354445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c619412abae7035e1d19ca400354445">&#9670;&nbsp;</a></span>buf_raw_read_map_16bit_be()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16* buf_raw_read_map_16bit_be </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1" title="Return a 16-bit pointer to read data from a buffer. ">buf_raw_read_map_16bit()</a></code>, but map words big-endian. </p>

</div>
</div>
<a id="af1487fe4d868796279b6617b561efbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1487fe4d868796279b6617b561efbd4">&#9670;&nbsp;</a></span>buf_raw_read_map_16bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint16* buf_raw_read_map_16bit_save_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1" title="Return a 16-bit pointer to read data from a buffer. ">buf_raw_read_map_16bit()</a></code>, but save the buffer state. </p>
<p><code>save_state</code> will be used to save buffer state that can be restored later. </p>

</div>
</div>
<a id="a3fca5a3daf2be592424b0c2451cc74e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fca5a3daf2be592424b0c2451cc74e0">&#9670;&nbsp;</a></span>buf_raw_read_map_8bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8* buf_raw_read_map_8bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an 8-bit pointer to read data from a buffer. </p>
<p>The buffer is mapped for read access at the output location (<code>outdex</code>) and a pointer is returned. The view of the data is 8-bit-wide.</p>
<p>After the data is read, <code><a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update()</a></code> should be called to indicate how many octets were read. This updates <code>outdex</code>. </p>

</div>
</div>
<a id="a995bef6dac1e7993c4b2bc24fc39a798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995bef6dac1e7993c4b2bc24fc39a798">&#9670;&nbsp;</a></span>buf_raw_read_map_8bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8* buf_raw_read_map_8bit_save_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a3fca5a3daf2be592424b0c2451cc74e0" title="Return an 8-bit pointer to read data from a buffer. ">buf_raw_read_map_8bit()</a></code>, but save the buffer state. </p>
<p><code>save_state</code> should point to memory at least <code>MMU_SAVE_STATE_WORDS</code> long. This will be used to save buffer state that can be restored later. </p>

</div>
</div>
<a id="a7693faf6ae446d42d36c95103edb9923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7693faf6ae446d42d36c95103edb9923">&#9670;&nbsp;</a></span>buf_raw_read_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_read_unmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buf_raw_read_only_unmap - unmap the buffer from reading ONLY. </p>
<dl class="section user"><dt>FUNCTION</dt><dd>This function unmaps the buffer from the read port. A buffer that is mapped using any of the buf_raw_read_only_map_xxx functions MUST be unmapped once it is done with the reading of this buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>If a nested function is called after mapping a buffer but before unmapping it, the nested function MUST use xxx_save_state functions to map the buffer. The unmapping is done using the appropriate unmap function. Additionally the buf state MUST be restored using one of the appropriate restore functions. If a read/write update is required, it can use xxx_update_restore fucntions, otherwise it can use buf_raw_buf_restore_state(). </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the updation of the message length is unaffected by this new buffer usage model </dd></dl>
<dl class="section user"><dt></dt><dd>Example usage: </dd></dl>
<dl class="section user"><dt></dt><dd>fn1 { uint8 *p_data1; ...... p_data1 = buf_raw_read_only_map_8bit(buffer1); </dd></dl>
<dl class="section user"><dt></dt><dd>read few bytes from the buffer1 </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2); // nested function </dd></dl>
<dl class="section user"><dt></dt><dd>buf_raw_read_only_unmap(); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the outdex needs to be updated <a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update(buffer1)</a>; } </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2) { uint8 *p_data2; ...... </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the distance between index and outdex is more than the memcpy length to ensure the source and destination buffer sections are non-overlapping p_rdata = buf_raw_read_map_8bit_save_state(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>p_wdata = buf_raw_write_only_map_8bit(buffer2); memcpy(p_wdata, p_rdata, len); <a class="el" href="../../d5/d08/buffer_8h.html#a32d7283d658069aff4371deb75af60df" title="buf_raw_write_only_unmap - unmap the buffer for writing ONLY. ">buf_raw_write_only_unmap()</a>; </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the index needs to be updated <a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update(buffer2)</a>; </dd></dl>
<dl class="section user"><dt></dt><dd>nbuf_raw_read_unmap(); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if index needs to be updated. buf_raw_read_update_restore(buffer2) </dd></dl>
<dl class="section user"><dt></dt><dd>If neither outdex nor back needs to be updated buf_raw_buf_restore_state(); } </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>buf_raw_read_only_unmap - unmap the buffer from reading ONLY. </p>

</div>
</div>
<a id="a7d2034090b59dc9cb8991cbb3073a137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2034090b59dc9cb8991cbb3073a137">&#9670;&nbsp;</a></span>buf_raw_read_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_read_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>octets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <code>outdex</code> for a buffer after reading <code>octets</code> octets from it. </p>
<p>If the buffer was read in 16-bit mode <code>octets</code> must be even. </p>

</div>
</div>
<a id="aab3ac40d544d4d88d1c77174adf41d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ac40d544d4d88d1c77174adf41d4c">&#9670;&nbsp;</a></span>buf_raw_read_update_restore_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_read_update_restore_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>octets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update()</a></code> but restore a previously saved buffer state. </p>
<p><code>save_state</code> is the same pointer passed to the read map call. </p>

</div>
</div>
<a id="a7852702c4b87f8fcc72e80e2a5f99085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7852702c4b87f8fcc72e80e2a5f99085">&#9670;&nbsp;</a></span>buf_raw_read_write_map_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_read_write_map_16bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an 16-bit pointer to read and write data in a buffer. </p>
<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a384130a90d9f0150b9a0e55d6eddc0b1" title="Return a 16-bit pointer to read data from a buffer. ">buf_raw_read_map_16bit()</a></code> but additionally with write mapping. </p>

</div>
</div>
<a id="a6bfcaa61798e84d3a3195feb45941d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfcaa61798e84d3a3195feb45941d20">&#9670;&nbsp;</a></span>buf_raw_read_write_map_16bit_be()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_read_write_map_16bit_be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a7852702c4b87f8fcc72e80e2a5f99085" title="Return an 16-bit pointer to read and write data in a buffer. ">buf_raw_read_write_map_16bit()</a></code> but map words big-endian. </p>

</div>
</div>
<a id="ae72d4f6deec19d1aac30c95ea7007022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72d4f6deec19d1aac30c95ea7007022">&#9670;&nbsp;</a></span>buf_raw_read_write_map_16bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_read_write_map_16bit_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#af1487fe4d868796279b6617b561efbd4" title="As buf_raw_read_map_16bit(), but save the buffer state. ">buf_raw_read_map_16bit_save_state()</a></code>, but mapped read/write. </p>

</div>
</div>
<a id="a4b6dfd642c59dc5c805d058c752aeab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6dfd642c59dc5c805d058c752aeab4">&#9670;&nbsp;</a></span>buf_raw_read_write_map_8bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_read_write_map_8bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an 8-bit pointer to read and write data in a buffer. </p>
<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a3fca5a3daf2be592424b0c2451cc74e0" title="Return an 8-bit pointer to read data from a buffer. ">buf_raw_read_map_8bit()</a></code> but additionally with write mapping. </p>

</div>
</div>
<a id="af2747238ccd5d9e5826bfef2b1437835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2747238ccd5d9e5826bfef2b1437835">&#9670;&nbsp;</a></span>buf_raw_read_write_map_8bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_read_write_map_8bit_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a995bef6dac1e7993c4b2bc24fc39a798" title="As buf_raw_read_map_8bit(), but save the buffer state. ">buf_raw_read_map_8bit_save_state()</a></code>, but mapped read/write. </p>

</div>
</div>
<a id="a26d85451a93ba4de7f15cdab10b84fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d85451a93ba4de7f15cdab10b84fa9">&#9670;&nbsp;</a></span>buf_raw_read_write_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_read_write_unmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buf_raw_read_write_unmap - unmap the buffer from reading and writing. </p>
<dl class="section user"><dt>FUNCTION</dt><dd>This function unmaps the buffer from the read and write ports. A buffer that is mapped using any of the buf_raw_read_write_map_xxx functions MUST be unmapped once it is done with the reading/writing of this buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>If a nested function is called after mapping a buffer but before unmapping it, the nested function MUST use xxx_save_state functions to map the buffer. The unmapping is done using the appropriate unmap function. Additionally the buf state MUST be restored using one of the appropriate restore functions. If a read/write update is required, it can use xxx_update_restore fucntions, otherwise it can use buf_raw_buf_restore_state() </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the updation of the message length is unaffected by this new buffer usage model </dd></dl>
<dl class="section user"><dt></dt><dd>Example usage: </dd></dl>
<dl class="section user"><dt></dt><dd>fn1 { uint8 *p_data1; ...... p_data1 = buf_raw_read_write_map_8bit(buffer1); </dd></dl>
<dl class="section user"><dt></dt><dd>read/write few bytes from the buffer1 </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2); // nested function </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="../../d5/d08/buffer_8h.html#a26d85451a93ba4de7f15cdab10b84fa9" title="buf_raw_read_write_unmap - unmap the buffer from reading and writing. ">buf_raw_read_write_unmap()</a>; </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the outdex needs to be updated <a class="el" href="../../d5/d08/buffer_8h.html#afbb3ffe11ef8e820d91906282016fd93" title="Updating the outdex can be done as a macro. ">buf_raw_read_update(buffer1)</a>; } </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2) { uint8 *p_rdata; ...... </dd></dl>
<dl class="section user"><dt></dt><dd>p_data2 = buf_raw_read_write_map_8bit_save_state(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>read/write few bytes from the buffer2 </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="../../d5/d08/buffer_8h.html#a26d85451a93ba4de7f15cdab10b84fa9" title="buf_raw_read_write_unmap - unmap the buffer from reading and writing. ">buf_raw_read_write_unmap()</a>; </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the outdex needs to be updated buf_raw_read_update_restore(buffer2); OR If neither outdex nor back needs to be updated buf_raw_buf_restore_state(); }</dd></dl>
<p>buf_raw_read_write_unmap - unmap the buffer from reading and writing. </p>

</div>
</div>
<a id="a4067623274d4ad0a35209e8e5633ccc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4067623274d4ad0a35209e8e5633ccc2">&#9670;&nbsp;</a></span>buf_raw_update_tail_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_update_tail_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>new_tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the tail pointer, freeing any memory no longer needed. </p>
<p>The new pointer is used to replace the old tail pointer. Any memory between the two pointers is a candidate for freeing. It will only be freed if a complete page is now unused; this is handled by <code>mmu_free_buffer_memory()</code>.</p>
<p>This function does not map buffer memory.</p>
<p>Note the difference in parameters between this and functions that update after writing (<code>index</code>) or reading (<code>outdex</code>): in this case, the second parameter is the new value of the <code>tail</code>, not the length to add to the old <code>tail</code>. I'm not sure why that is. </p>

</div>
</div>
<a id="a72afd9466f19bd0c8bbff2a796624f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72afd9466f19bd0c8bbff2a796624f66">&#9670;&nbsp;</a></span>buf_raw_write_map_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_write_map_16bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a 16-bit pointer to write data to a buffer. </p>
<p>The buffer is mapped for read/write access at the input location (<code>index</code>) and a pointer is returned. The view of the data is 16-bit-wide. <code>index</code> must be even or this causes a panic; the caller must ensure all updates to buffers that will be accessed in 16-bit mode use even byte counts.</p>
<p>After the data is written, <code><a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update()</a></code> should be called to indicate how many octets were written. This updates <code>index</code>. Note the argument really is in octets even though half that number of words will have been written. </p>

</div>
</div>
<a id="ac87e8d2c8f79a06fcb8bca6c608f2add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87e8d2c8f79a06fcb8bca6c608f2add">&#9670;&nbsp;</a></span>buf_raw_write_map_16bit_be()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_write_map_16bit_be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code> but map words big-endian. </p>

</div>
</div>
<a id="a53c1fd4e30b5ed58969c5bbb21afcef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c1fd4e30b5ed58969c5bbb21afcef0">&#9670;&nbsp;</a></span>buf_raw_write_map_16bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_write_map_16bit_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code>, but save the buffer state. </p>
<p><code>save_state</code> will be used to save buffer state that can be restored later. </p>

</div>
</div>
<a id="ac06e9de8299f864e44d69fb078cffe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06e9de8299f864e44d69fb078cffe3b">&#9670;&nbsp;</a></span>buf_raw_write_map_8bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_write_map_8bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an 8-bit pointer to write data to a buffer. </p>
<p>The buffer is mapped for read/write access at the input location (<code>index</code>) and a pointer is returned. The view of the data is 8-bit-wide.</p>
<p>After the data is written, <code><a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update()</a></code> should be called to indicate how many octets were written. This updates <code>index</code>. </p>

</div>
</div>
<a id="add61b72438ea4a46db80e4b91298589d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add61b72438ea4a46db80e4b91298589d">&#9670;&nbsp;</a></span>buf_raw_write_map_8bit_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_write_map_8bit_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalisation of <code>buf_raw_write_map_8bit</code> to return read/write access at an arbitrary position within the buffer. </p>
<p>WARNING: No check is performed on the validity of <code>position</code> wrt mapping in of pages! </p>

</div>
</div>
<a id="a7246abc8b54d560da27322f13c9b2f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7246abc8b54d560da27322f13c9b2f64">&#9670;&nbsp;</a></span>buf_raw_write_map_8bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_write_map_8bit_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit()</a></code>, but save the buffer state. </p>
<p><code>save_state</code> will be used to save buffer state that can be restored later. </p>

</div>
</div>
<a id="ad0ecb3dff3a3de6075aed7727dbb8984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecb3dff3a3de6075aed7727dbb8984">&#9670;&nbsp;</a></span>buf_raw_write_only_map_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_write_only_map_16bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a72afd9466f19bd0c8bbff2a796624f66" title="Return a 16-bit pointer to write data to a buffer. ">buf_raw_write_map_16bit()</a></code>, but map write only, not read/write. </p>
<p>This is necessary for copying between buffers when a simultaneous read mapping is used. </p>

</div>
</div>
<a id="a66caf410e5a9e077886195afb45c277a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66caf410e5a9e077886195afb45c277a">&#9670;&nbsp;</a></span>buf_raw_write_only_map_16bit_be()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* buf_raw_write_only_map_16bit_be </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#ad0ecb3dff3a3de6075aed7727dbb8984" title="As buf_raw_write_map_16bit(), but map write only, not read/write. ">buf_raw_write_only_map_16bit()</a></code>, but map words big-endian. </p>

</div>
</div>
<a id="ad399d8df2a54cbf038824af7f44ee61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399d8df2a54cbf038824af7f44ee61e">&#9670;&nbsp;</a></span>buf_raw_write_only_map_8bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_write_only_map_8bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit()</a></code>, but map write only, not read/write. </p>
<p>This is necessary for copying between buffers when a simultaneous read mapping is used. </p>

</div>
</div>
<a id="ac188166a34563d506f78a4e8edf44b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac188166a34563d506f78a4e8edf44b3a">&#9670;&nbsp;</a></span>buf_raw_write_only_map_8bit_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* buf_raw_write_only_map_8bit_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#ad399d8df2a54cbf038824af7f44ee61e" title="As buf_raw_write_map_8bit(), but map write only, not read/write. ">buf_raw_write_only_map_8bit()</a></code>, but save the buffer state. </p>
<p>This is necessary for copying between buffers when a simultaneous read mapping is used. </p>

</div>
</div>
<a id="a32d7283d658069aff4371deb75af60df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d7283d658069aff4371deb75af60df">&#9670;&nbsp;</a></span>buf_raw_write_only_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_write_only_unmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buf_raw_write_only_unmap - unmap the buffer for writing ONLY. </p>
<dl class="section user"><dt>FUNCTION</dt><dd>This function unmaps the buffer from the write port. A buffer that is mapped using any of the nbuf_raw_write_only_map_xxx functions MUST be unmapped once it is done with the writing of this buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>If a nested function is called after mapping a buffer but before unmapping it, the nested function MUST use xxx_save_state functions to map the buffer. The unmapping is done using the appropriate unmap function. Additionally the buf state MUST be restored using one of the appropriate restore functions. If a write update is required, it can use xxx_update_restore fucntions, otherwise it can use buf_raw_buf_restore_state() </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the updation of the message length is unaffected by this new buffer usage model </dd></dl>
<dl class="section user"><dt></dt><dd>Example usage: </dd></dl>
<dl class="section user"><dt></dt><dd>fn1 { uint8 *p_data1; ...... p_data1 = buf_raw_write_only_map_8bit(buffer1); </dd></dl>
<dl class="section user"><dt></dt><dd>write few bytes to the buffer1 </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2); // nested function </dd></dl>
<dl class="section user"><dt></dt><dd>buf_raw_write_only_unmap(buffer1); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the index needs to be updated <a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update(buffer1)</a>; } </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2) { uint8 *p_data2; ...... </dd></dl>
<dl class="section user"><dt></dt><dd>p_data2 = buf_raw_write_only_map_8bit_save_state(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>write few bytes to the buffer2 </dd></dl>
<dl class="section user"><dt></dt><dd>buf_raw_write_only_unmap(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the index needs to be updated buf_raw_write_update_restore(buffer2); OR If neither index nor front needs to be updated buf_raw_buf_restore_state(); } </dd></dl>
<dl class="section user"><dt></dt><dd>See the <a class="el" href="../../d5/d08/buffer_8h.html#a7693faf6ae446d42d36c95103edb9923" title="buf_raw_read_only_unmap - unmap the buffer from reading ONLY. ">buf_raw_read_unmap()</a> header for an example of a nested function that copies one section of the buffer to another non-overlapped section of the same buffer. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>buf_raw_write_only_unmap - unmap the buffer for writing ONLY. </p>

</div>
</div>
<a id="a355996f344f863eeb53b20c964ed1207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355996f344f863eeb53b20c964ed1207">&#9670;&nbsp;</a></span>buf_raw_write_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_write_unmap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buf_raw_write_unmap - unmap the buffer from reading and writing. </p>
<dl class="section user"><dt>FUNCTION</dt><dd>This function unmaps the buffer from the read and write ports. A buffer that is mapped using any of the buf_raw_write_map_xxx functions MUST be unmapped once it is done with the reading/writing of this buffer. </dd></dl>
<dl class="section user"><dt></dt><dd>If a nested function is called after mapping a buffer but before unmapping it, the nested function MUST use xxx_save_state functions to map the buffer. The unmapping is done using the appropriate unmap function. Additionally the buf state MUST be restored using one of the appropriate restore functions. If a write update is required, it can use xxx_update_restore functions, otherwise it can use buf_raw_buf_restore_state() </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the updation of the message length is unaffected by this new buffer usage model </dd></dl>
<dl class="section user"><dt></dt><dd>Example usage: </dd></dl>
<dl class="section user"><dt></dt><dd>fn1 { uint8 *p_data1; ...... p_data1 = <a class="el" href="../../d5/d08/buffer_8h.html#a6fdb2427659f55768fbe4809aff06d5e">buf_raw_write_map_8bit(buffer1)</a>; </dd></dl>
<dl class="section user"><dt></dt><dd>write/read few bytes to/from the buffer1 </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2); // nested function </dd></dl>
<dl class="section user"><dt></dt><dd>buf_raw_write_unmap(buffer1); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the index needs to be updated <a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update(buffer1)</a>; } </dd></dl>
<dl class="section user"><dt></dt><dd>fn2(buffer2) { uint8 *p_data2; ...... </dd></dl>
<dl class="section user"><dt></dt><dd>p_data2 = buf_raw_write_map_8bit_save_state(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>write/read few bytes to/from the buffer2 </dd></dl>
<dl class="section user"><dt></dt><dd>buf_raw_write_unmap(buffer2); </dd></dl>
<dl class="section user"><dt></dt><dd>This is required only if the index needs to be updated buf_raw_write_update_restore(buffer2); OR In case neither index nor front needs to be updated buf_raw_buf_restore_state(); }</dd></dl>
<p>buf_raw_write_unmap - unmap the buffer from reading and writing. </p>

</div>
</div>
<a id="a1b2417ba06058092bb6a576f528dbb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2417ba06058092bb6a576f528dbb98">&#9670;&nbsp;</a></span>buf_raw_write_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_write_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>octets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update <code>index</code> for a buffer after writing <code>octets</code> octets to it. </p>
<p>If the buffer was written in 16-bit mode <code>octets</code> must be even. </p>

</div>
</div>
<a id="a5c58d0e9eeb322481a98e1c44655d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c58d0e9eeb322481a98e1c44655d62b">&#9670;&nbsp;</a></span>buf_raw_write_update_restore_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_raw_write_update_restore_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d1a/structBUFFER.html">BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>octets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <code><a class="el" href="../../d5/d08/buffer_8h.html#a43bbf3b5fc9f2ee5dfbe7235ad9a065c" title="Updating the index can be done as a macro. ">buf_raw_write_update()</a></code> but restore a previously saved buffer state. </p>

</div>
</div>
<a id="a12fc64024808b973f06e93754aea39b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc64024808b973f06e93754aea39b9">&#9670;&nbsp;</a></span>buf_restore_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_restore_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4194054835aa28e3944513bcd10000e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4194054835aa28e3944513bcd10000e">&#9670;&nbsp;</a></span>buf_save_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_save_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dd/df4/structbuf__mapping__state.html">buf_mapping_state</a> *&#160;</td>
          <td class="paramname"><em>save_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_9104b11b055a08855e18ab07d1360a34.html">apps_ext_adk64r_RC_CI_qcc512x_qcc302x_1908091004</a></li><li class="navelem"><a class="el" href="../../dir_19c4644e84b768df42bf93899dbb4e83.html">apps_package</a></li><li class="navelem"><a class="el" href="../../dir_e9f51238b5eab91050ba7b42263dc658.html">progfiles</a></li><li class="navelem"><a class="el" href="../../dir_86fefe393b7ca9a63838560cf4ca04cf.html">apps</a></li><li class="navelem"><a class="el" href="../../dir_240681f6dc407f95ae9103d80499b5b4.html">fw</a></li><li class="navelem"><a class="el" href="../../dir_67a3fc20251395f7d62aa73621d4d7c9.html">src</a></li><li class="navelem"><a class="el" href="../../dir_721b2a6acf65b21a05ec9c4de6b97c06.html">core</a></li><li class="navelem"><a class="el" href="../../dir_6c005c01fd2244f24e1000ec33094419.html">buffer</a></li><li class="navelem"><a class="el" href="../../d5/d08/buffer_8h.html">buffer.h</a></li>
    <li class="footer">Copyright (c) 2019 Qualcomm Technologies International, Ltd. Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
