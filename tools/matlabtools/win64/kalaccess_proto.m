function [methodinfo,structs,enuminfo,ThunkLibName]=kalaccess_proto
%KALACCESS_PROTO Create structures to define interfaces found in 'kalaccess_matlab'.

%This function was generated by loadlibrary.m parser version  on Thu Jun 14 14:34:48 2018
%perl options:'kalaccess_matlab.i -outfile=kalaccess_proto.m -thunkfile=kalaccess_thunk_pcwin64.c -header=kalaccess_matlab.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'kalaccess_thunk_pcwin64');
% void ka_free_error ( ka_err * err ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='ka_free_error'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'ka_errPtr'};fcnNum=fcnNum+1;
% const char * ka_trans_get_var ( voidPtr ka , const char * var ); 
fcns.thunkname{fcnNum}='cstringvoidPtrcstringThunk';fcns.name{fcnNum}='ka_trans_get_var'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}={'voidPtr', 'cstring'};fcnNum=fcnNum+1;
% void ka_trans_set_var ( voidPtr ka , const char * var , const char * val ); 
fcns.thunkname{fcnNum}='voidvoidPtrcstringcstringThunk';fcns.name{fcnNum}='ka_trans_set_var'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'voidPtr', 'cstring', 'cstring'};fcnNum=fcnNum+1;
% ka_err * ka_trans_build_device_table ( ka_connection_detailsPtr * table , int * count ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_trans_build_device_table'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'ka_connection_detailsPtrPtr', 'int32Ptr'};fcnNum=fcnNum+1;
% void ka_trans_free_device_table ( ka_connection_details * table , int count ); 
fcns.thunkname{fcnNum}='voidvoidPtrint32Thunk';fcns.name{fcnNum}='ka_trans_free_device_table'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'ka_connection_detailsPtr', 'int32'};fcnNum=fcnNum+1;
% ka_err * ka_connect ( ka_connection_details const * conn_details , bool ignore_fw , voidPtr * kalaccess_result ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrboolvoidPtrThunk';fcns.name{fcnNum}='ka_connect'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'ka_connection_detailsPtr', 'bool', 'voidPtrPtr'};fcnNum=fcnNum+1;
% ka_err * ka_connect_uri ( char const * uri , voidPtr * kalaccess_result ); 
fcns.thunkname{fcnNum}='voidPtrcstringvoidPtrThunk';fcns.name{fcnNum}='ka_connect_uri'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'cstring', 'voidPtrPtr'};fcnNum=fcnNum+1;
% ka_err * ka_connect_simple ( char const * transport_string , bool ignore_fw , voidPtr * kalaccess_result ); 
fcns.thunkname{fcnNum}='voidPtrcstringboolvoidPtrThunk';fcns.name{fcnNum}='ka_connect_simple'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'cstring', 'bool', 'voidPtrPtr'};fcnNum=fcnNum+1;
% void ka_disconnect ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='ka_disconnect'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int32 ka_get_chip_rev ( voidPtr ka ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='ka_get_chip_rev'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% const char * ka_get_chip_name ( voidPtr ka ); 
fcns.thunkname{fcnNum}='cstringvoidPtrThunk';fcns.name{fcnNum}='ka_get_chip_name'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% bool ka_check_chip_name ( voidPtr ka , const char * name ); 
fcns.thunkname{fcnNum}='boolvoidPtrcstringThunk';fcns.name{fcnNum}='ka_check_chip_name'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='bool'; fcns.RHS{fcnNum}={'voidPtr', 'cstring'};fcnNum=fcnNum+1;
% uint32 ka_get_arch ( voidPtr ka ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='ka_get_arch'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% uint32 ka_get_arch_from_name ( const char * name ); 
fcns.thunkname{fcnNum}='uint32cstringThunk';fcns.name{fcnNum}='ka_get_arch_from_name'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'cstring'};fcnNum=fcnNum+1;
% uint32 ka_get_register_width ( voidPtr ka , int32 id ); 
fcns.thunkname{fcnNum}='uint32voidPtrint32Thunk';fcns.name{fcnNum}='ka_get_register_width'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int32 ka_get_register_id ( voidPtr ka , const char * name ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringThunk';fcns.name{fcnNum}='ka_get_register_id'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring'};fcnNum=fcnNum+1;
% const char * * ka_get_register_names (); 
fcns.thunkname{fcnNum}='voidPtrThunk';fcns.name{fcnNum}='ka_get_register_names'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='stringPtrPtr'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
% uint32 ka_hal_get_max_pm_breakpoints ( voidPtr ka ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='ka_hal_get_max_pm_breakpoints'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_set_pm_breakpoint ( voidPtr ka , uint32 breakpoint_num , uint32 addr ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32uint32Thunk';fcns.name{fcnNum}='ka_hal_set_pm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_clear_pm_breakpoint ( voidPtr ka , uint32 breakpoint_num ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_clear_pm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_get_pm_breakpoint ( voidPtr ka , uint32 breakpoint_num , uint32 * addr , bool * enabled ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_get_pm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'boolPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_clear_all_pm_breakpoints ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_clear_all_pm_breakpoints'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% uint32 ka_hal_get_max_dm_breakpoints ( voidPtr ka ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='ka_hal_get_max_dm_breakpoints'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_set_dm_breakpoint ( voidPtr ka , uint32 breakpoint_num , uint32 startAddress , uint32 endAddress , bool triggerOnRead , bool triggerOnWrite ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32uint32uint32boolboolThunk';fcns.name{fcnNum}='ka_hal_set_dm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32', 'uint32', 'bool', 'bool'};fcnNum=fcnNum+1;
% ka_err * ka_hal_clear_dm_breakpoint ( voidPtr ka , uint32 breakpoint_num ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_clear_dm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_get_dm_breakpoint ( voidPtr ka , uint32 breakpoint_num , uint32 * startAddress , uint32 * endAddress , bool * triggerOnRead , bool * triggerOnWrite ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_get_dm_breakpoint'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32Ptr', 'boolPtr', 'boolPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_clear_all_dm_breakpoints ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_clear_all_dm_breakpoints'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_read_pm_block ( voidPtr ka , uint32 start_addr , uint32 * data , uint32 num_words ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_read_pm_block'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_write_pm_block ( voidPtr ka , uint32 start_addr , uint32 * data , uint32 num_words ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_write_pm_block'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_read_dm_block ( voidPtr ka , uint32 start_addr , uint32 * data , uint32 num_words ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_read_dm_block'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_write_dm_block ( voidPtr ka , uint32 start_addr , uint32 * data , uint32 num_words ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_write_dm_block'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_read_register ( voidPtr ka , int32 reg , uint32 * result ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='ka_hal_read_register'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'int32', 'uint32Ptr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_write_register ( voidPtr ka , int32 reg , uint32 val ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrint32uint32Thunk';fcns.name{fcnNum}='ka_hal_write_register'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'int32', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_spi_read ( voidPtr ka , uint32 addr , uint16 * data ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtrThunk';fcns.name{fcnNum}='ka_hal_spi_read'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16Ptr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_spi_write ( voidPtr ka , uint32 addr , uint16 data ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32uint16Thunk';fcns.name{fcnNum}='ka_hal_spi_write'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16'};fcnNum=fcnNum+1;
% ka_err * ka_hal_jtag_read ( voidPtr ka , uint32 addr , uint32 * data , uint32 numOctets ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_jtag_read'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_jtag_write ( voidPtr ka , uint32 addr , uint32 * data , uint32 numOctets ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtruint32voidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_jtag_write'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_pcprofile ( voidPtr ka , uint32 * sample_data , uint32 num_samples ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ka_hal_pcprofile'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% ka_err * ka_hal_run ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_run'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_pause ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_pause'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_step ( voidPtr ka ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_step'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% ka_err * ka_hal_read_dsp_enable ( voidPtr ka , bool * enabled ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_hal_read_dsp_enable'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'boolPtr'};fcnNum=fcnNum+1;
% ka_err * ka_get_chip_state ( voidPtr ka , int * state ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ka_get_chip_state'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='ka_errPtr'; fcns.RHS{fcnNum}={'voidPtr', 'int32Ptr'};fcnNum=fcnNum+1;
structs.ka_err.members=struct('err_code', 'int32', 'err_string', 'cstring');
structs.ka_connection_details.members=struct('transport_string', 'cstring', 'subsys_id', 'int32', 'processor_id', 'uint32', 'dongle_id', 'cstring');
methodinfo=fcns;